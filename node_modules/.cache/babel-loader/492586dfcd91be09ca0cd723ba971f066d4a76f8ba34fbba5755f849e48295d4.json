{"ast":null,"code":"var _jsxFileName = \"/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FaceScan = () => {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [faceLandmarker, setFaceLandmarker] = useState(null);\n  const [webcamRunning, setWebcamRunning] = useState(false);\n  useEffect(() => {\n    // Load and create the face landmarker\n    const loadModel = async () => {\n      // Import the necessary MediaPipe modules here\n      // const vision = await import('path_to_mediapipe_vision');\n      // const { FaceLandmarker, FilesetResolver } = vision;\n\n      const filesetResolver = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');\n      const loadedFaceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: 'GPU'\n        },\n        outputFaceBlendshapes: true,\n        runningMode: 'IMAGE',\n        numFaces: 1\n      });\n      setFaceLandmarker(loadedFaceLandmarker);\n    };\n    loadModel();\n  }, []);\n  const startWebcam = () => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices.getUserMedia({\n        video: true\n      }).then(stream => {\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      }).catch(error => {\n        console.error('Error accessing the webcam', error);\n      });\n    }\n  };\n\n  // Function to handle enabling the webcam\n  const enableCam = () => {\n    if (!faceLandmarker) {\n      console.log(\"Wait! faceLandmarker not loaded yet.\");\n      return;\n    }\n    if (webcamRunning) {\n      setWebcamRunning(false);\n    } else {\n      setWebcamRunning(true);\n      startWebcam();\n    }\n  };\n\n  // Function to predict webcam and draw landmarks\n  const predictWebcam = async () => {\n    // Prediction and drawing logic goes here\n  };\n  useEffect(() => {\n    if (webcamRunning && videoRef.current) {\n      videoRef.current.addEventListener('loadeddata', predictWebcam);\n    }\n    return () => {\n      if (videoRef.current) {\n        videoRef.current.removeEventListener('loadeddata', predictWebcam);\n      }\n    };\n  }, [webcamRunning, faceLandmarker]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        transform: 'scaleX(-1)'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef /* Set canvas dimensions here */\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: enableCam,\n      children: webcamRunning ? 'Disable Webcam' : 'Enable Webcam'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 83,\n    columnNumber: 9\n  }, this);\n};\n_s(FaceScan, \"b0Ctrgdksfjru0NfwVR5t1q9jtk=\");\n_c = FaceScan;\nexport default FaceScan;\nvar _c;\n$RefreshReg$(_c, \"FaceScan\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","FaceScan","_s","videoRef","canvasRef","faceLandmarker","setFaceLandmarker","webcamRunning","setWebcamRunning","loadModel","filesetResolver","FilesetResolver","forVisionTasks","loadedFaceLandmarker","FaceLandmarker","createFromOptions","baseOptions","modelAssetPath","delegate","outputFaceBlendshapes","runningMode","numFaces","startWebcam","navigator","mediaDevices","getUserMedia","video","then","stream","current","srcObject","catch","error","console","enableCam","log","predictWebcam","addEventListener","removeEventListener","children","ref","autoPlay","playsInline","style","transform","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\nconst FaceScan = () => {\n    const videoRef = useRef(null);\n    const canvasRef = useRef(null);\n    const [faceLandmarker, setFaceLandmarker] = useState(null);\n    const [webcamRunning, setWebcamRunning] = useState(false);\n\n    useEffect(() => {\n        // Load and create the face landmarker\n        const loadModel = async () => {\n            // Import the necessary MediaPipe modules here\n            // const vision = await import('path_to_mediapipe_vision');\n            // const { FaceLandmarker, FilesetResolver } = vision;\n\n            const filesetResolver = await FilesetResolver.forVisionTasks(\n                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'\n            );\n\n            const loadedFaceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n                baseOptions: {\n                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n                    delegate: 'GPU',\n                },\n                outputFaceBlendshapes: true,\n                runningMode: 'IMAGE',\n                numFaces: 1,\n            });\n\n            setFaceLandmarker(loadedFaceLandmarker);\n        };\n\n        loadModel();\n    }, []);\n\n    const startWebcam = () => {\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            navigator.mediaDevices.getUserMedia({ video: true })\n                .then(stream => {\n                    if (videoRef.current) {\n                        videoRef.current.srcObject = stream;\n                    }\n                })\n                .catch(error => {\n                    console.error('Error accessing the webcam', error);\n                });\n        }\n    };\n\n    // Function to handle enabling the webcam\n    const enableCam = () => {\n        if (!faceLandmarker) {\n            console.log(\"Wait! faceLandmarker not loaded yet.\");\n            return;\n        }\n\n        if (webcamRunning) {\n            setWebcamRunning(false);\n        } else {\n            setWebcamRunning(true);\n            startWebcam();\n        }\n    };\n\n    // Function to predict webcam and draw landmarks\n    const predictWebcam = async () => {\n        // Prediction and drawing logic goes here\n    };\n\n    useEffect(() => {\n        if (webcamRunning && videoRef.current) {\n            videoRef.current.addEventListener('loadeddata', predictWebcam);\n        }\n\n        return () => {\n            if (videoRef.current) {\n                videoRef.current.removeEventListener('loadeddata', predictWebcam);\n            }\n        };\n    }, [webcamRunning, faceLandmarker]);\n\n    return (\n        <div>\n            <video ref={videoRef} autoPlay playsInline style={{ transform: 'scaleX(-1)' }} />\n            <canvas ref={canvasRef} /* Set canvas dimensions here */ />\n            <button onClick={enableCam}>{webcamRunning ? 'Disable Webcam' : 'Enable Webcam'}</button>\n        </div>\n    );\n};\n\nexport default FaceScan;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}