{"ast":null,"code":"var _jsxFileName = \"/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport vision from '@mediapipe/vision';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FaceScan = () => {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [faceLandmarker, setFaceLandmarker] = useState(null);\n  const [webcamRunning, setWebcamRunning] = useState(false);\n\n  // Load the face landmarker model\n  useEffect(() => {\n    const loadModel = async () => {\n      // Import the necessary MediaPipe modules\n      const vision = await import('@mediapipe/tasks-vision');\n      const {\n        FaceLandmarker,\n        FilesetResolver\n      } = vision;\n      const filesetResolver = await FilesetResolver.forVisionTasks(\n        // CDN path to the MediaPipe WASM files\n      );\n      const loadedFaceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath: 'URL to the face_landmarker.task file',\n          delegate: 'GPU'\n        },\n        outputFaceBlendshapes: true,\n        runningMode: 'VIDEO',\n        numFaces: 1\n      });\n      setFaceLandmarker(loadedFaceLandmarker);\n    };\n    loadModel();\n  }, []);\n\n  // Start the webcam\n  const startWebcam = async () => {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true\n    });\n    videoRef.current.srcObject = stream;\n  };\n\n  // Handle webcam and drawing\n  useEffect(() => {\n    if (webcamRunning && faceLandmarker) {\n      startWebcam();\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n      const onFrame = async () => {\n        if (!faceLandmarker || !videoRef.current) return;\n        const results = await faceLandmarker.send({\n          image: videoRef.current\n        });\n        if (results && results.multiFaceLandmarks) {\n          drawLandmarks(context, canvas, results.multiFaceLandmarks);\n        }\n        requestAnimationFrame(onFrame);\n      };\n      onFrame();\n    }\n  }, [webcamRunning, faceLandmarker]);\n\n  // Function to draw landmarks\n  const drawLandmarks = (context, canvas, landmarks) => {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // Drawing logic goes here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        display: webcamRunning ? 'block' : 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 73,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef /* Set canvas dimensions here */\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 74,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setWebcamRunning(!webcamRunning),\n      children: webcamRunning ? 'Stop Webcam' : 'Start Webcam'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 72,\n    columnNumber: 9\n  }, this);\n};\n_s(FaceScan, \"b0Ctrgdksfjru0NfwVR5t1q9jtk=\");\n_c = FaceScan;\nexport default FaceScan;\nvar _c;\n$RefreshReg$(_c, \"FaceScan\");","map":{"version":3,"names":["React","useEffect","useRef","useState","vision","jsxDEV","_jsxDEV","FaceScan","_s","videoRef","canvasRef","faceLandmarker","setFaceLandmarker","webcamRunning","setWebcamRunning","loadModel","FaceLandmarker","FilesetResolver","filesetResolver","forVisionTasks","loadedFaceLandmarker","createFromOptions","baseOptions","modelAssetPath","delegate","outputFaceBlendshapes","runningMode","numFaces","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","canvas","context","getContext","onFrame","results","send","image","multiFaceLandmarks","drawLandmarks","requestAnimationFrame","landmarks","clearRect","width","height","children","ref","autoPlay","playsInline","style","display","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport vision from '@mediapipe/vision';\n\nconst FaceScan = () => {\n    const videoRef = useRef(null);\n    const canvasRef = useRef(null);\n    const [faceLandmarker, setFaceLandmarker] = useState(null);\n    const [webcamRunning, setWebcamRunning] = useState(false);\n\n    // Load the face landmarker model\n    useEffect(() => {\n        const loadModel = async () => {\n            // Import the necessary MediaPipe modules\n            const vision = await import('@mediapipe/tasks-vision');\n            const { FaceLandmarker, FilesetResolver } = vision;\n\n            const filesetResolver = await FilesetResolver.forVisionTasks(\n                // CDN path to the MediaPipe WASM files\n            );\n\n            const loadedFaceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {\n                baseOptions: {\n                    modelAssetPath: 'URL to the face_landmarker.task file',\n                    delegate: 'GPU',\n                },\n                outputFaceBlendshapes: true,\n                runningMode: 'VIDEO',\n                numFaces: 1,\n            });\n\n            setFaceLandmarker(loadedFaceLandmarker);\n        };\n\n        loadModel();\n    }, []);\n\n    // Start the webcam\n    const startWebcam = async () => {\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        videoRef.current.srcObject = stream;\n    };\n\n    // Handle webcam and drawing\n    useEffect(() => {\n        if (webcamRunning && faceLandmarker) {\n            startWebcam();\n            const canvas = canvasRef.current;\n            const context = canvas.getContext('2d');\n\n            const onFrame = async () => {\n                if (!faceLandmarker || !videoRef.current) return;\n\n                const results = await faceLandmarker.send({ image: videoRef.current });\n                if (results && results.multiFaceLandmarks) {\n                    drawLandmarks(context, canvas, results.multiFaceLandmarks);\n                }\n\n                requestAnimationFrame(onFrame);\n            };\n\n            onFrame();\n        }\n    }, [webcamRunning, faceLandmarker]);\n\n    // Function to draw landmarks\n    const drawLandmarks = (context, canvas, landmarks) => {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        // Drawing logic goes here\n    };\n\n    return (\n        <div>\n            <video ref={videoRef} autoPlay playsInline style={{ display: webcamRunning ? 'block' : 'none' }} />\n            <canvas ref={canvasRef} /* Set canvas dimensions here */ />\n            <button onClick={() => setWebcamRunning(!webcamRunning)}>\n                {webcamRunning ? 'Stop Webcam' : 'Start Webcam'}\n            </button>\n        </div>\n    );\n};\n\nexport default FaceScan;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}