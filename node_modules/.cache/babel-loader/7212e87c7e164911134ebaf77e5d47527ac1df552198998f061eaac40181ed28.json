{"ast":null,"code":"var _jsxFileName = \"/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as vision from '@mediapipe/tasks-vision';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FaceScan = () => {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [faceLandmarker, setFaceLandmarker] = useState(null);\n  const [webcamRunning, setWebcamRunning] = useState(false);\n  useEffect(() => {\n    // Load and create the face landmarker\n    const loadModel = async () => {\n      const {\n        FaceLandmarker,\n        FilesetResolver\n      } = vision;\n      const filesetResolver = await vision.FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');\n      const loadedFaceLandmarker = await vision.FaceLandmarker.createFromOptions(filesetResolver, {\n        baseOptions: {\n          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: 'GPU'\n        },\n        outputFaceBlendshapes: true,\n        runningMode: 'IMAGE',\n        numFaces: 1\n      });\n      setFaceLandmarker(loadedFaceLandmarker);\n    };\n    loadModel();\n  }, []);\n  const startWebcam = () => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices.getUserMedia({\n        video: true\n      }).then(stream => {\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      }).catch(error => {\n        console.error('Error accessing the webcam', error);\n      });\n    }\n  };\n\n  // Function to handle enabling the webcam\n  const enableCam = () => {\n    if (!faceLandmarker) {\n      console.log(\"Wait! faceLandmarker not loaded yet.\");\n      return;\n    }\n    if (webcamRunning) {\n      setWebcamRunning(false);\n    } else {\n      setWebcamRunning(true);\n      startWebcam();\n    }\n  };\n  const predictWebcam = async () => {\n    if (!faceLandmarker || !videoRef.current || !canvasRef.current) return;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    const drawLandmarks = landmarks => {\n      context.fillStyle = 'blue';\n      landmarks.forEach(landmark => {\n        context.beginPath();\n        context.arc(landmark.x * canvas.width, landmark.y * canvas.height, 5, 0, 2 * Math.PI);\n        context.fill();\n      });\n    };\n    const detect = async () => {\n      if (!videoRef.current || !webcamRunning) return;\n\n      // Perform the detection\n      const results = await faceLandmarker.detect(video);\n      if (results && results.multiFaceLandmarks) {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        for (const landmarks of results.multiFaceLandmarks) {\n          drawLandmarks(landmarks); // Draw landmarks for each face\n        }\n      }\n      requestAnimationFrame(detect); // Continue the loop\n    };\n    detect();\n  };\n  useEffect(() => {\n    if (webcamRunning && videoRef.current) {\n      videoRef.current.addEventListener('loadeddata', predictWebcam);\n    }\n    return () => {\n      if (videoRef.current) {\n        videoRef.current.removeEventListener('loadeddata', predictWebcam);\n      }\n    };\n  }, [webcamRunning, faceLandmarker]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        transform: 'scaleX(-1)'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef /* canvas dimension */\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: enableCam,\n      children: webcamRunning ? 'Disable Webcam' : 'Enable Webcam'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 118,\n    columnNumber: 9\n  }, this);\n};\n_s(FaceScan, \"b0Ctrgdksfjru0NfwVR5t1q9jtk=\");\n_c = FaceScan;\nexport default FaceScan;\nvar _c;\n$RefreshReg$(_c, \"FaceScan\");","map":{"version":3,"names":["React","useEffect","useRef","useState","vision","jsxDEV","_jsxDEV","FaceScan","_s","videoRef","canvasRef","faceLandmarker","setFaceLandmarker","webcamRunning","setWebcamRunning","loadModel","FaceLandmarker","FilesetResolver","filesetResolver","forVisionTasks","loadedFaceLandmarker","createFromOptions","baseOptions","modelAssetPath","delegate","outputFaceBlendshapes","runningMode","numFaces","startWebcam","navigator","mediaDevices","getUserMedia","video","then","stream","current","srcObject","catch","error","console","enableCam","log","predictWebcam","canvas","context","getContext","width","videoWidth","height","videoHeight","drawLandmarks","landmarks","fillStyle","forEach","landmark","beginPath","arc","x","y","Math","PI","fill","detect","results","multiFaceLandmarks","clearRect","requestAnimationFrame","addEventListener","removeEventListener","children","ref","autoPlay","playsInline","style","transform","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/ibrakhimu/Desktop/skincare copy/src/pages/FaceScan.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport * as vision from '@mediapipe/tasks-vision';\n\n\nconst FaceScan = () => {\n    const videoRef = useRef(null);\n    const canvasRef = useRef(null);\n    const [faceLandmarker, setFaceLandmarker] = useState(null);\n    const [webcamRunning, setWebcamRunning] = useState(false);\n\n    useEffect(() => {\n        // Load and create the face landmarker\n        const loadModel = async () => {\n            const { FaceLandmarker, FilesetResolver } = vision;\n\n            const filesetResolver = await vision.FilesetResolver.forVisionTasks(\n                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'\n            );\n\n            const loadedFaceLandmarker = await vision.FaceLandmarker.createFromOptions(filesetResolver, {\n                baseOptions: {\n                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n                    delegate: 'GPU',\n                },\n                outputFaceBlendshapes: true,\n                runningMode: 'IMAGE',\n                numFaces: 1,\n            });\n\n            setFaceLandmarker(loadedFaceLandmarker);\n        };\n\n        loadModel();\n    }, []);\n\n    const startWebcam = () => {\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            navigator.mediaDevices.getUserMedia({ video: true })\n                .then(stream => {\n                    if (videoRef.current) {\n                        videoRef.current.srcObject = stream;\n                    }\n                })\n                .catch(error => {\n                    console.error('Error accessing the webcam', error);\n                });\n        }\n    };\n\n    // Function to handle enabling the webcam\n    const enableCam = () => {\n        if (!faceLandmarker) {\n            console.log(\"Wait! faceLandmarker not loaded yet.\");\n            return;\n        }\n\n        if (webcamRunning) {\n            setWebcamRunning(false);\n        } else {\n            setWebcamRunning(true);\n            startWebcam();\n        }\n    };\n\n    const predictWebcam = async () => {\n        if (!faceLandmarker || !videoRef.current || !canvasRef.current) return;\n    \n        const video = videoRef.current;\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n    \n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n    \n        const drawLandmarks = (landmarks) => {\n            context.fillStyle = 'blue';\n            landmarks.forEach(landmark => {\n                context.beginPath();\n                context.arc(landmark.x * canvas.width, landmark.y * canvas.height, 5, 0, 2 * Math.PI);\n                context.fill();\n            });\n        };\n    \n        const detect = async () => {\n            if (!videoRef.current || !webcamRunning) return;\n    \n            // Perform the detection\n            const results = await faceLandmarker.detect(video);\n    \n            if (results && results.multiFaceLandmarks) {\n                context.clearRect(0, 0, canvas.width, canvas.height);\n    \n                for (const landmarks of results.multiFaceLandmarks) {\n                    drawLandmarks(landmarks); // Draw landmarks for each face\n                }\n            }\n    \n            requestAnimationFrame(detect); // Continue the loop\n        };\n    \n        detect();\n    };\n    \n\n    useEffect(() => {\n        if (webcamRunning && videoRef.current) {\n            videoRef.current.addEventListener('loadeddata', predictWebcam);\n        }\n\n        return () => {\n            if (videoRef.current) {\n                videoRef.current.removeEventListener('loadeddata', predictWebcam);\n            }\n        };\n    }, [webcamRunning, faceLandmarker]);\n\n    return (\n        <div>\n            <video ref={videoRef} autoPlay playsInline style={{ transform: 'scaleX(-1)' }} />\n            <canvas ref={canvasRef} /* canvas dimension */ />\n            <button onClick={enableCam}>{webcamRunning ? 'Disable Webcam' : 'Enable Webcam'}</button>\n        </div>\n    );\n};\n\nexport default FaceScan;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}